{"version":3,"file":"JSONCalc.js","sourceRoot":"","sources":["JSONCalc.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,mCAAgI;AAChI,2DAA2D;AAqB3D,MAAa,QAAQ;IAQT,MAAM,CAAC,kBAAkB,CAAC,cAAmB,EAAE,IAAc;QACjE,IAAI,eAAe,GAAgB,EAAE,CAAC;QAEtC,IAAI,iBAAQ,CAAC,cAAc,CAAC,EAAE;YAC1B,+DAA+D;YAC9D,cAAyB,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,QAAQ,CAAC,gBAAgB,EAAE,GAAG,CAAC,EAAE,CAAC,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,EAAE;gBAC7G,eAAe,CAAC,IAAI,CAAC;oBACjB,QAAQ,EAAE,QAAQ;oBAClB,UAAU,EAAE,UAAU;iBACzB,CAAC,CAAC;gBACH,OAAO,EAAE,CAAC;YACd,CAAC,CAAC,CAAC;SACN;aAAM,IAAI,qBAAY,CAAC,cAAc,CAAC,EAAE;YACrC,iDAAiD;YACjD,IAAI,WAAW,GAAG,YAAG,CAAC,cAAc,EAAE,QAAQ,CAAC,sBAAsB,CAAC,CAAC;YACvE,IAAI,iBAAQ,CAAC,WAAW,CAAC,EAAE;gBACvB,IAAI,SAAS,GAAG,QAAQ,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;gBACzD,IAAI,CAAC,cAAK,CAAC,SAAS,CAAC,EAAE;oBACnB,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;iBACnC;aACJ;iBAAM,2EAA2E;aAClF;gBACI,aAAI,CAAC,cAAc,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE;oBAChC,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;oBACnC,eAAe,GAAG,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC,kBAAkB,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC,CAAC;gBAC5F,CAAC,CAAC,CAAC;aACN;SACJ;QAED,OAAO,eAAM,CAAC,eAAe,EAAE,CAAC,SAAoB,EAAE,EAAE,CAAC,SAAS,CAAC,QAAQ,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC;IACxG,CAAC;IAEO,MAAM,CAAC,6BAA6B,CAAC,SAAiB;QAC1D,IAAI,YAAY,GAAG,gBAAO,CAAC,SAAS,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,EAAE;YACxD,OAAO,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;QAC3D,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,cAAK,CAAC,YAAY,CAAC,EAAE;YACtB,OAAO;gBACH,IAAI,EAAE,YAAY;gBAClB,OAAO,EAAE,YAAG,CAAC,SAAS,EAAE,YAAY,CAAC;aACxC,CAAC;SACL;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;OAGG;IACH,MAAM,CAAC,kBAAkB,CAAC,eAAuB;QAE7C,IAAI,eAA0B,CAAC;QAE/B,eAAe,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE,CAAC,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,EAAE;YAE3F,eAAe,GAAG;gBACd,QAAQ,EAAE,QAAQ;gBAClB,UAAU,EAAE,UAAU;aACzB,CAAC;YAEF,OAAO,EAAE,CAAC;QACd,CAAC,CAAC,CAAC;QAEH,OAAO,eAAe,CAAC;IAC3B,CAAC;IAED;;;OAGG;IACH,MAAM,CAAC,iBAAiB,CAAC,cAAmB;QACxC,OAAO,QAAQ,CAAC,kBAAkB,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC;IAC3D,CAAC;IAEO,MAAM,CAAO,kBAAkB,CAAC,OAAY,EACZ,QAAgB,EAChB,UAAkB,EAClB,iBAAoC,EACpC,aAAyB,EAAE,EAC3B,kBAAsC,EACtC,QAAkB,EAAE;;YAExD,IAAI,OAAO,GAAG,GAAG,cAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,QAAQ,GAAG,GAAG,UAAU,EAAE,CAAC;YAEtE,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE;gBAC/B,MAAM,IAAI,KAAK,CAAC,2CAA2C,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aAClF;YAED,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YAEhC,IAAI,KAAK,CAAC;YAEV,4BAA4B;YAC5B,IAAI,CAAC,cAAK,CAAC,QAAQ,CAAC,EAAE;gBAClB,OAAO,GAAG,UAAU,CAAC,QAAQ,CAAC,CAAC;gBAE/B,IAAI,cAAK,CAAC,OAAO,CAAC,IAAI,CAAC,cAAK,CAAC,iBAAiB,CAAC,EAAE;oBAC7C,OAAO,GAAG,MAAM,iBAAiB,CAAC,QAAQ,CAAC,CAAC;oBAC5C,UAAU,CAAC,QAAQ,CAAC,GAAG,OAAO,CAAC;iBAClC;aACJ;YAED,uEAAuE;YACvE,IAAI,eAAe,GAAG,eAAM,CAAC,UAAU,CAAC,CAAC;YACzC,IAAI,iBAAiB,GAAG,EAAE,CAAC;YAC3B,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC5B,KAAK,IAAI,cAAc,IAAI,eAAe,EAAE;oBACxC,iBAAiB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;oBAEvC,IAAI,KAAK,GAAG,YAAG,CAAC,OAAO,EAAE,iBAAiB,CAAC,CAAC;oBAC5C,IAAI,YAAY,GAAG,QAAQ,CAAC,6BAA6B,CAAC,KAAK,CAAC,CAAC;oBAEjE,mGAAmG;oBACnG,IAAI,CAAC,cAAK,CAAC,YAAY,CAAC,EAAE;wBACtB,IAAI,MAAM,GAAG,MAAM,QAAQ,CAAC,eAAe,CAAC,KAAK,EAAE,OAAO,EAAE,iBAAiB,EAAE,UAAU,EAAE,kBAAkB,EAAE,KAAK,CAAC,CAAC;wBACtH,YAAG,CAAC,OAAO,EAAE,iBAAiB,EAAE,MAAM,CAAC,CAAC;wBACxC,MAAM;qBACT;iBACJ;aACJ;YAED,yCAAyC;YACzC,IAAG,YAAG,CAAC,OAAO,EAAE,UAAU,CAAC,EAC3B;gBACI,KAAK,GAAG,kBAAS,CAAC,YAAG,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC,CAAC;aAC/C;iBACI,IAAG,CAAC,cAAK,CAAC,kBAAkB,CAAC,EAClC;gBACI,+EAA+E;gBAC/E,KAAK,GAAG,MAAM,kBAAkB,CAAC,MAAM,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;aAC/D;YAED,OAAO,MAAM,QAAQ,CAAC,eAAe,CAAC,KAAK,EAAE,OAAO,EAAE,iBAAiB,EAAE,UAAU,EAAE,kBAAkB,EAAE,KAAK,CAAC,CAAC;QACpH,CAAC;KAAA;IAEO,MAAM,CAAO,eAAe,CAAC,cAA+B,EAC/B,OAAY,EACZ,iBAAoC,EACpC,aAAyB,EAAE,EAC3B,kBAAsC,EACtC,QAAkB,EAAE;;YACrD,IAAI,iBAAQ,CAAC,cAAc,CAAC,EAAE;gBAE1B,OAAO,kBAAkB,CACpB,cAAyB,EAC1B,IAAI,MAAM,CAAC,QAAQ,CAAC,gBAAgB,EAAE,GAAG,CAAC,EAC1C,CAAO,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,EAAE;oBAEpC,OAAO;oBACH,IAAI,KAAK,GAAG,MAAM,QAAQ,CAAC,kBAAkB,CAAC,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,iBAAiB,EAAE,UAAU,EAAE,kBAAkB,EAAE,KAAK,CAAC,CAAC;oBAEvI,IAAI,cAAK,CAAC,KAAK,CAAC,EAAE;wBACd,KAAK,GAAG,QAAQ,CAAC,yBAAyB,CAAC;qBAC9C;yBAAM,IAAI,qBAAY,CAAC,KAAK,CAAC,EAAE;wBAC5B,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;qBACjC;yBAAM;wBACH,KAAK,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC;qBAC5B;oBAED,OAAO,KAAK,CAAC;oBACjB;;uBAEG;gBACP,CAAC,CAAA,CAAC,CAAC;aAEV;iBAAM,IAAI,qBAAY,CAAC,cAAc,CAAC,EAAE;gBAErC,IAAI,YAAY,GAAG,QAAQ,CAAC,6BAA6B,CAAC,cAAwB,CAAC,CAAC;gBAEpF,IAAI,CAAC,cAAK,CAAC,YAAY,CAAC,EAAE;oBACtB,IAAI,YAAY,CAAC,IAAI,KAAK,QAAQ,CAAC,sBAAsB,IAAI,iBAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,EAAE;wBACzF,IAAI,SAAS,GAAG,QAAQ,CAAC,kBAAkB,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;wBAClE,IAAI;4BACA,OAAO,MAAM,QAAQ,CAAC,kBAAkB,CAAC,OAAO,EAAE,SAAS,CAAC,QAAQ,EAAE,SAAS,CAAC,UAAU,EAAE,iBAAiB,EAAE,UAAU,EAAE,kBAAkB,EAAE,KAAK,CAAC,CAAC;yBACzJ;wBAAC,OAAO,CAAC,EAAE;4BACR,OAAO,CAAC,CAAC;yBACZ;qBACJ;yBAAM;wBACH,YAAY,CAAC,OAAO,GAAG,MAAM,QAAQ,CAAC,eAAe,CAAC,YAAY,CAAC,OAAO,EAAE,OAAO,EAAE,iBAAiB,EAAE,UAAU,EAAE,kBAAkB,EAAE,KAAK,CAAC,CAAC;wBAE/I,IAAI,UAAU,CAAC;wBACf,IAAI,CAAC,cAAK,CAAC,kBAAkB,CAAC,EAAE;4BAC5B,UAAU,GAAG,MAAM,kBAAkB,CAAC,YAAY,CAAC,IAAI,EAAE,YAAY,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;yBAEzF;wBAED,OAAO,oBAAW,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,UAAU,CAAC;qBAChE;iBACJ;qBAAM;oBAEH,IAAI,OAAO,GAAG,YAAG,CAAC,cAAc,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE;wBAC7C,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;4BACnC,QAAQ,CAAC,eAAe,CAAC,KAAK,EAAE,OAAO,EAAE,iBAAiB,EAAE,UAAU,EAAE,kBAAkB,EAAE,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;gCAC9G,cAAc,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;gCAC5B,OAAO,EAAE,CAAC;4BACd,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;wBACrB,CAAC,CAAC,CAAC;oBACP,CAAC,CAAC,CAAC;oBAEH,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;iBAC9B;aACJ;YAED,OAAO,cAAc,CAAC;QAC1B,CAAC;KAAA;IAED;;;;;;OAMG;IACH,MAAM,CAAO,cAAc,CAAC,cAA+B,EAC/B,OAAY,EACZ,iBAAqC,EACrC,kBAAuC;;YAC/D,OAAO,QAAQ,CAAC,eAAe,CAAC,cAAc,EAAE,OAAO,EAAE,iBAAiB,EAAE,EAAE,EAAE,kBAAkB,CAAC,CAAC;QACxG,CAAC;KAAA;IAED;;;;;;;OAOG;IACH,MAAM,CAAO,GAAG,CAAC,MAAc,EACd,IAAuB,EACvB,iBAAqC,EACrC,kBAAuC,EACvC,YAAkB;;YAC/B,IAAI,OAAO,GAAG,kBAAS,CAAC,MAAM,CAAC,CAAC;YAChC,IAAI,KAAK,GAAG,cAAK,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,YAAG,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;YAE3E,KAAK,GAAG,MAAM,QAAQ,CAAC,cAAc,CAAC,KAAK,EAAE,OAAO,EAAE,iBAAiB,EAAE,kBAAkB,CAAC,CAAC;YAE7F,IAAI,cAAK,CAAC,KAAK,CAAC,EAAE;gBACd,OAAO,YAAY,CAAC;aACvB;YAED,OAAO,KAAK,CAAC;QACjB,CAAC;KAAA;;AA3PM,uBAAc,GAAG,iBAAiB,CAAC;AACnC,yBAAgB,GAAG,sBAAsB,CAAC;AAC1C,wBAAe,GAAG,GAAG,CAAC;AACtB,+BAAsB,GAAG,GAAG,QAAQ,CAAC,eAAe,KAAK,CAAC;AAC1D,kCAAyB,GAAG,SAAS,CAAC;AANjD,4BA8PC","sourcesContent":["import {get, set, isString, isObjectLike, each, map, has, isNil, cloneDeep, uniqBy, findKey, toPath, isUndefined} from \"lodash\";\nimport * as stringReplaceAsync from \"string-replace-async\";\n\ntype RemoteDocs = { [location: string]: any };\n\n/**\n * A reference.\n */\nexport interface Reference {\n    location?: string;\n    objectPath?: string;\n}\n\ninterface ReferenceProviderData {\n    name: string;\n    options: any;\n}\n\n\nexport type RemoteDocProvider = (location: string) => Promise<any>;\nexport type CustomDataProvider = (providerName: string, providerOptions?: any, path?:string[]) => Promise<any>;\n\nexport class JSONCalc {\n\n    static REFERENCE_PATH = \"(?:(.+?)#)?(.+)\";\n    static STRING_REFERENCE = `{{(?:(.+?)#)?(.+?)}}`;\n    static PROVIDER_PREFIX = \"$\";\n    static REFERENCE_PROVIDER_KEY = `${JSONCalc.PROVIDER_PREFIX}ref`;\n    static MISSING_VALUE_PLACEHOLDER = \"#VALUE!\";\n\n    private static _extractReferences(objectOrString: any, path: string[]): Reference[] {\n        let foundReferences: Reference[] = [];\n\n        if (isString(objectOrString)) {\n            // Extract references in the form of {{something}} from strings\n            (objectOrString as string).replace(new RegExp(JSONCalc.STRING_REFERENCE, \"g\"), (fullRef, location, objectPath) => {\n                foundReferences.push({\n                    location: location,\n                    objectPath: objectPath\n                });\n                return \"\";\n            });\n        } else if (isObjectLike(objectOrString)) {\n            // Look for values that look like {$:\"something\"}\n            let objectValue = get(objectOrString, JSONCalc.REFERENCE_PROVIDER_KEY);\n            if (isString(objectValue)) {\n                let reference = JSONCalc.parseReferencePath(objectValue);\n                if (!isNil(reference)) {\n                    foundReferences.push(reference);\n                }\n            } else // Otherwise, recursively loop through all children and look for references\n            {\n                each(objectOrString, (value, key) => {\n                    let childPath = path.concat([key]);\n                    foundReferences = foundReferences.concat(JSONCalc._extractReferences(value, childPath));\n                });\n            }\n        }\n\n        return uniqBy(foundReferences, (reference: Reference) => reference.location + reference.objectPath);\n    }\n\n    private static _extractReferenceProviderData(theObject: object): ReferenceProviderData {\n        let providerName = findKey(theObject, (keyValue, keyName) => {\n            return keyName.indexOf(JSONCalc.PROVIDER_PREFIX) === 0;\n        });\n\n        if (!isNil(providerName)) {\n            return {\n                name: providerName,\n                options: get(theObject, providerName)\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * Will parse a reference path into the individual constituents.\n     * @param referenceString - A string in the form of `[remoteURI#]localPath`. See readme for more details.\n     */\n    static parseReferencePath(referenceString: string): Reference {\n\n        let returnReference: Reference;\n\n        referenceString.replace(new RegExp(JSONCalc.REFERENCE_PATH), (fullRef, location, objectPath) => {\n\n            returnReference = {\n                location: location,\n                objectPath: objectPath\n            };\n\n            return \"\";\n        });\n\n        return returnReference;\n    }\n\n    /**\n     * Extract a list of references within a string or an object\n     * @param objectOrString - The string or object to extract references from.\n     */\n    static extractReferences(objectOrString: any): Reference[] {\n        return JSONCalc._extractReferences(objectOrString, []);\n    }\n\n    private static async _getReferenceValue(dataDoc: any,\n                                            location: string,\n                                            objectPath: string,\n                                            remoteDocProvider: RemoteDocProvider,\n                                            remoteDocs: RemoteDocs = {},\n                                            customDataProvider: CustomDataProvider,\n                                            stack: string[] = []): Promise<any> {\n\n        let stackID = `${isNil(location) ? \"\" : `${location}#`}${objectPath}`;\n\n        if (stack.indexOf(stackID) !== -1) {\n            throw new Error(`Document contains a circular reference: ${stack.join(\"->\")}`);\n        }\n\n        stack = stack.concat([stackID]);\n\n        let value;\n\n        // This is a remote document\n        if (!isNil(location)) {\n            dataDoc = remoteDocs[location];\n\n            if (isNil(dataDoc) && !isNil(remoteDocProvider)) {\n                dataDoc = await remoteDocProvider(location);\n                remoteDocs[location] = dataDoc;\n            }\n        }\n\n        // Traverse down the object path to see if it has any object references\n        let objectPathParts = toPath(objectPath);\n        let currentObjectPath = [];\n        if (objectPathParts.length > 0) {\n            for (let objectPathPart of objectPathParts) {\n                currentObjectPath.push(objectPathPart);\n\n                let value = get(dataDoc, currentObjectPath);\n                let providerData = JSONCalc._extractReferenceProviderData(value);\n\n                // If this contains an object reference, we need to fill the reference before we can go any further\n                if (!isNil(providerData)) {\n                    let result = await JSONCalc._fillReferences(value, dataDoc, remoteDocProvider, remoteDocs, customDataProvider, stack);\n                    set(dataDoc, currentObjectPath, result);\n                    break;\n                }\n            }\n        }\n\n        // Does this value exist in our data doc?\n        if(has(dataDoc, objectPath))\n        {\n            value = cloneDeep(get(dataDoc, objectPath));\n        }\n        else if(!isNil(customDataProvider))\n        {\n            // If this value doesn't exist, allow the CustomDataProvider to provide a value\n            value = await customDataProvider(\"$ref\", objectPath, stack);\n        }\n\n        return await JSONCalc._fillReferences(value, dataDoc, remoteDocProvider, remoteDocs, customDataProvider, stack);\n    }\n\n    private static async _fillReferences(objectOrString: string | object,\n                                         dataDoc: any,\n                                         remoteDocProvider: RemoteDocProvider,\n                                         remoteDocs: RemoteDocs = {},\n                                         customDataProvider: CustomDataProvider,\n                                         stack: string[] = []): Promise<any> {\n        if (isString(objectOrString)) {\n\n            return stringReplaceAsync(\n                (objectOrString as string),\n                new RegExp(JSONCalc.STRING_REFERENCE, \"g\"),\n                async (fullRef, location, objectPath) => {\n\n                    //try {\n                        let value = await JSONCalc._getReferenceValue(dataDoc, location, objectPath, remoteDocProvider, remoteDocs, customDataProvider, stack);\n\n                        if (isNil(value)) {\n                            value = JSONCalc.MISSING_VALUE_PLACEHOLDER;\n                        } else if (isObjectLike(value)) {\n                            value = JSON.stringify(value);\n                        } else {\n                            value = value.toString();\n                        }\n\n                        return value;\n                    /*} catch (e) {\n                        return e;\n                    }*/\n                });\n\n        } else if (isObjectLike(objectOrString)) {\n\n            let providerData = JSONCalc._extractReferenceProviderData(objectOrString as object);\n\n            if (!isNil(providerData)) {\n                if (providerData.name === JSONCalc.REFERENCE_PROVIDER_KEY && isString(providerData.options)) {\n                    let reference = JSONCalc.parseReferencePath(providerData.options);\n                    try {\n                        return await JSONCalc._getReferenceValue(dataDoc, reference.location, reference.objectPath, remoteDocProvider, remoteDocs, customDataProvider, stack);\n                    } catch (e) {\n                        return e;\n                    }\n                } else {\n                    providerData.options = await JSONCalc._fillReferences(providerData.options, dataDoc, remoteDocProvider, remoteDocs, customDataProvider, stack);\n\n                    let customData;\n                    if (!isNil(customDataProvider)) {\n                        customData = await customDataProvider(providerData.name, providerData.options, stack);\n\n                    }\n\n                    return isUndefined(customData) ? objectOrString : customData;\n                }\n            } else {\n\n                let actions = map(objectOrString, (value, key) => {\n                    return new Promise((resolve, reject) => {\n                        JSONCalc._fillReferences(value, dataDoc, remoteDocProvider, remoteDocs, customDataProvider, stack).then((value) => {\n                            objectOrString[key] = value;\n                            resolve();\n                        }).catch(reject);\n                    });\n                });\n\n                await Promise.all(actions);\n            }\n        }\n\n        return objectOrString;\n    }\n\n    /**\n     * Fill references in an object or string.\n     * @param objectOrString - The object or string to find and fill in references within.\n     * @param dataDoc - The object that provides the data to that can be referenced. It may be the same object as as the `objectOrString` parameter.\n     * @param remoteDocProvider - A callback that will be invoked when a remote document is referenced and needed.\n     * @param customDataProvider - A callback that will be invoked when a custom data accessor is encountered.\n     */\n    static async fillReferences(objectOrString: string | object,\n                                dataDoc: any,\n                                remoteDocProvider?: RemoteDocProvider,\n                                customDataProvider?: CustomDataProvider): Promise<any> {\n        return JSONCalc._fillReferences(objectOrString, dataDoc, remoteDocProvider, {}, customDataProvider);\n    }\n\n    /**\n     * Fill references in an object at the given path.\n     * @param object - The to find and fill references within.\n     * @param path - The path within the object find and fill references. Anything at or below this path will be procesed.\n     * @param remoteDocProvider - A callback that will be invoked when a remote document is referenced and needed.\n     * @param customDataProvider - A callback that will be invoked when a custom data accessor is encountered.\n     * @param defaultValue - If no value is found, this optional value will be returned.\n     */\n    static async get(object: object,\n                     path: string | string[],\n                     remoteDocProvider?: RemoteDocProvider,\n                     customDataProvider?: CustomDataProvider,\n                     defaultValue?: any): Promise<any> {\n        let dataDoc = cloneDeep(object);\n        let value = isNil(path) || path.length === 0 ? dataDoc : get(object, path);\n\n        value = await JSONCalc.fillReferences(value, dataDoc, remoteDocProvider, customDataProvider);\n\n        if (isNil(value)) {\n            return defaultValue;\n        }\n\n        return value;\n    }\n}"]}