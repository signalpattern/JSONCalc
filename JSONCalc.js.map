{"version":3,"file":"JSONCalc.js","sourceRoot":"","sources":["JSONCalc.ts"],"names":[],"mappings":"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","sourcesContent":["import {get, set, isString, isObjectLike, each, map, has, isNil, cloneDeep, uniqBy, findKey, toPath, isUndefined} from \"lodash\";\nimport * as stringReplaceAsync from \"string-replace-async\";\n\n//type RemoteDocs = { [location: string]: any };\n\n/**\n * A reference.\n */\n\n/*export interface Reference {\n    location?: string;\n    objectPath?: string;\n}*/\n\ninterface CustomCalcOptions {\n    name: string;\n    options: any;\n}\n\n\n//export type RemoteDocProvider = (location: string) => Promise<any>;\nexport type CustomCalcProvider = (providerName: string, providerOptions?: any, dataPath?: string[]) => Promise<any>;\n\nexport class JSONCalc {\n\n    static CUSTOM_CALC_KEY_PREFIX = \"$\";\n    static STRING_REFERENCE_REGEX = \"{{(.+?)}}\";\n    static MISSING_VALUE_PLACEHOLDER = \"#VALUE!\";\n\n    /*static REFERENCE_PATH = \"(?:(.+?)#)?(.+)\";\n    static STRING_REFERENCE = `{{(?:(.+?)#)?(.+?)}}`;\n    static PROVIDER_PREFIX = \"$\";\n    static REFERENCE_PROVIDER_KEY = `${JSONCalc.PROVIDER_PREFIX}ref`;\n\n\n    private static _extractReferences(objectOrString: any, path: string[]): Reference[] {\n        let foundReferences: Reference[] = [];\n\n        if (isString(objectOrString)) {\n            // Extract references in the form of {{something}} from strings\n            (objectOrString as string).replace(new RegExp(JSONCalc.STRING_REFERENCE, \"g\"), (fullRef, location, objectPath) => {\n                foundReferences.push({\n                    location: location,\n                    objectPath: objectPath\n                });\n                return \"\";\n            });\n        } else if (isObjectLike(objectOrString)) {\n            // Look for values that look like {$:\"something\"}\n            let objectValue = get(objectOrString, JSONCalc.REFERENCE_PROVIDER_KEY);\n            if (isString(objectValue)) {\n                let reference = JSONCalc.parseReferencePath(objectValue);\n                if (!isNil(reference)) {\n                    foundReferences.push(reference);\n                }\n            } else // Otherwise, recursively loop through all children and look for references\n            {\n                each(objectOrString, (value, key) => {\n                    let childPath = path.concat([key]);\n                    foundReferences = foundReferences.concat(JSONCalc._extractReferences(value, childPath));\n                });\n            }\n        }\n\n        return uniqBy(foundReferences, (reference: Reference) => reference.location + reference.objectPath);\n    }*/\n\n    private static _extractCustomCalcOptions(theObject: object): CustomCalcOptions {\n        let providerName = findKey(theObject, (keyValue, keyName) => {\n            return keyName.indexOf(JSONCalc.CUSTOM_CALC_KEY_PREFIX) === 0;\n        });\n\n        if (!isNil(providerName)) {\n            return {\n                name: providerName,\n                options: get(theObject, providerName)\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * Will parse a reference path into the individual constituents.\n     * @param referenceString - A string in the form of `[remoteURI#]localPath`. See readme for more details.\n     */\n    /*static parseReferencePath(referenceString: string): Reference {\n\n        let returnReference: Reference;\n\n        referenceString.replace(new RegExp(JSONCalc.REFERENCE_PATH), (fullRef, location, objectPath) => {\n\n            returnReference = {\n                location: location,\n                objectPath: objectPath\n            };\n\n            return \"\";\n        });\n\n        return returnReference;\n    }*/\n\n    /**\n     * Extract a list of references within a string or an object\n     * @param objectOrString - The string or object to extract references from.\n     */\n    /*static extractReferences(objectOrString: any): Reference[] {\n        return JSONCalc._extractReferences(objectOrString, []);\n    }*/\n\n    /*private static async _getReferenceValue(dataDoc: any,\n                                            dataDocLocation: string,\n                                            objectPath: string,\n                                            remoteDocProvider: RemoteDocProvider,\n                                            remoteDocs: RemoteDocs = {},\n                                            customDataProvider: CustomCalcProvider,\n                                            stack: string[] = [],\n                                            dataPath: string[] = []): Promise<any> {\n\n        let value;\n\n        // Traverse down the object path to see if it has any object references\n        let objectPathParts = toPath(objectPath);\n        let currentObjectPath = [];\n        if (objectPathParts.length > 0) {\n            for (let objectPathPart of objectPathParts) {\n                currentObjectPath.push(objectPathPart);\n\n                let value = get(dataDoc, currentObjectPath);\n                let providerData = JSONCalc._extractCustomCalcOptions(value);\n\n                let newDataPath = cloneDeep(currentObjectPath);\n\n                if (!isNil(dataDocLocation) && newDataPath.length > 0) {\n                    newDataPath[0] = `${dataDocLocation}#${newDataPath[0]}`;\n                }\n\n                // If this contains an object reference, we need to fill the reference before we can go any further\n                if (!isNil(providerData)) {\n                    let result = await JSONCalc._fillReferences(value, dataDocLocation, dataDoc, remoteDocProvider, remoteDocs, customDataProvider, stack, newDataPath);\n                    set(dataDoc, currentObjectPath, result);\n                    break;\n                }\n            }\n        }\n\n        value = cloneDeep(get(dataDoc, objectPath));\n\n        // If the value is undefined, can we get this from a remote doc?\n        if (isUndefined(value) && !isNil(remoteDocProvider)) {\n            let reference = JSONCalc.parseReferencePath(objectPath);\n            if (!isNil(reference.location)) {\n                let remoteDoc = remoteDocs[reference.location];\n\n                if (isNil(remoteDoc) && !isNil(remoteDocProvider)) {\n                    remoteDoc = await remoteDocProvider(reference.location);\n                    remoteDocs[reference.location] = remoteDoc;\n                }\n\n                dataDoc = cloneDeep(remoteDoc);\n                dataDocLocation = reference.location;\n\n                return JSONCalc._getReferenceValue(dataDoc, dataDocLocation, reference.objectPath, remoteDocProvider, remoteDocs, customDataProvider, stack, dataPath);\n            }\n        }\n\n        if (isUndefined(value) && !isNil(customDataProvider)) {\n            // If this value doesn't exist, allow the CustomDataProvider to provide a value\n            value = await customDataProvider(\"$ref\", objectPath, dataPath);\n        }\n\n        return JSONCalc._fillReferences(value, dataDocLocation, dataDoc, remoteDocProvider, remoteDocs, customDataProvider, stack, dataPath);\n    }\n\n    private static async _fillReferences(objectOrString: string | object,\n                                         dataDoc: any,\n                                         dataDocLocation: string,\n                                         remoteDocProvider: RemoteDocProvider,\n                                         remoteDocs: RemoteDocs = {},\n                                         customDataProvider: CustomCalcProvider,\n                                         stack: string[] = [],\n                                         dataPath: string[] = []): Promise<any> {\n        if (isString(objectOrString)) {\n            // This is a string, replace any string references in the form of {{reference}}\n            return stringReplaceAsync(\n                objectOrString as string,\n                new RegExp(JSONCalc.STRING_REFERENCE, \"g\"),\n                async (fullRef: string) => {\n\n                    fullRef = fullRef.replace(/[{}]/g, \"\");\n\n                    let value = await JSONCalc._getReferenceValue(dataDoc, dataDocLocation, fullRef, remoteDocProvider, remoteDocs, customDataProvider, stack, dataPath);\n\n                    if (isNil(value)) {\n                        value = JSONCalc.MISSING_VALUE_PLACEHOLDER;\n                    } else if (isObjectLike(value)) {\n                        value = JSON.stringify(value);\n                    } else {\n                        value = value.toString();\n                    }\n\n                    return value;\n                });\n\n        } else if (isObjectLike(objectOrString)) {\n            // Does this have a custom data action?\n            let providerData = JSONCalc._extractCustomCalcOptions(objectOrString as object);\n\n            if (!isNil(providerData)) {\n                // This is a reference to other data\n                if (providerData.name === JSONCalc.REFERENCE_PROVIDER_KEY && isString(providerData.options)) {\n\n                    try {\n                        return await JSONCalc._getReferenceValue(dataDoc, dataDocLocation, providerData.options, remoteDocProvider, remoteDocs, customDataProvider, stack, dataPath);\n                    } catch (e) {\n                        return e;\n                    }\n                } else {\n                    providerData.options = await JSONCalc._fillReferences(providerData.options, dataDoc, dataDocLocation, remoteDocProvider, remoteDocs, customDataProvider, stack, dataPath);\n\n                    let customData;\n                    if (!isNil(customDataProvider)) {\n                        customData = await customDataProvider(providerData.name, providerData.options, dataPath);\n                    }\n\n                    return isUndefined(customData) ? objectOrString : customData;\n                }\n            } else {\n                // This is a plain old object, loop through it and look for any references in it\n                let actions = map(objectOrString, (value, key) => {\n                    return new Promise((resolve, reject) => {\n                        JSONCalc._fillReferences(value, dataDoc, dataDocLocation, remoteDocProvider, remoteDocs, customDataProvider, stack.concat(key), dataPath.concat(key)).then((value) => {\n                            objectOrString[key] = value;\n                            resolve();\n                        }).catch(reject);\n                    });\n                });\n\n                await Promise.all(actions);\n            }\n        }\n\n        return objectOrString;\n    }*/\n\n    private static async _processCustomCalcOptions(calcOption: CustomCalcOptions,\n                                                   calculatorDoc: object,\n                                                   customCalcProvider: CustomCalcProvider,\n                                                   refStack: string[] = []): Promise<any> {\n        switch (calcOption.name) {\n            case \"$ref\": {\n                let referencePathString = calcOption.options;\n\n                if (refStack.indexOf(referencePathString) !== -1) {\n                    throw new Error(`Circular reference: ${refStack.join(\"->\")}`);\n                }\n\n                let currentPath = toPath(referencePathString);\n                let objectValue;\n\n                while(currentPath.length > 0)\n                {\n                    if(has(calculatorDoc, currentPath))\n                    {\n                        objectValue = get(calculatorDoc, currentPath);\n                        break;\n                    }\n\n                    currentPath.pop();\n                }\n\n                // Give the custom calc provider an opportunity to give a value\n                if(isUndefined(objectValue) && !isNil(customCalcProvider))\n                {\n                    objectValue = await customCalcProvider(calcOption.name, calcOption.options);\n                }\n                else\n                {\n                    objectValue = await JSONCalc._calculate(objectValue, calculatorDoc, customCalcProvider, refStack.concat([referencePathString]));\n                }\n\n                if(!isUndefined(objectValue))\n                {\n                    if(currentPath.length > 0)\n                    {\n                        set(calculatorDoc, currentPath, objectValue);\n                        return get(calculatorDoc, referencePathString);\n                    }\n\n                    return objectValue;\n                }\n\n                return undefined;\n            }\n            default: {\n                if (!isNil(customCalcProvider)) {\n                    return customCalcProvider(calcOption.name, calcOption.options);\n                }\n            }\n        }\n    }\n\n    private static async _calculate(objectToCalculate: string | object,\n                                    calculatorDoc: object,\n                                    customCalcProvider?: CustomCalcProvider,\n                                    refStack: string[] = []): Promise<any> {\n\n        if (isString(objectToCalculate)) {\n            // This is a string, let's go through and replace any references in the form of {{reference}}\n            return stringReplaceAsync(\n                objectToCalculate as string,\n                new RegExp(JSONCalc.STRING_REFERENCE_REGEX, \"g\"),\n                async (fullRef: string, refString: string) => {\n                    let returnString = await JSONCalc._processCustomCalcOptions({name: \"$ref\", options: refString}, calculatorDoc, customCalcProvider, refStack);\n\n                    if(isNil(returnString))\n                    {\n                        returnString = JSONCalc.MISSING_VALUE_PLACEHOLDER;\n                    }\n                    else if(isObjectLike(returnString))\n                    {\n                        returnString = JSON.stringify(returnString);\n                    }\n\n                    return returnString;\n                });\n\n        } else if (isObjectLike(objectToCalculate)) {\n            let customCalcOptions = JSONCalc._extractCustomCalcOptions(objectToCalculate as object);\n\n            if (!isNil(customCalcOptions)) {\n                // This is a custom calc object.\n                return JSONCalc._processCustomCalcOptions(customCalcOptions, calculatorDoc, customCalcProvider, refStack)\n            } else {\n                // This is just a standard object. Loop through every key, value and process each.\n                let promises = map(objectToCalculate, async (value, key) => {\n                    objectToCalculate[key] = await JSONCalc._calculate(value, calculatorDoc, customCalcProvider, refStack);\n                });\n\n                await Promise.all(promises);\n            }\n        }\n\n        return objectToCalculate;\n    }\n\n    static async calculate(objectToCalculate: object | string,\n                           calculatorDoc: object,\n                           customCalcProvider?: CustomCalcProvider): Promise<any> {\n        return this._calculate(objectToCalculate, calculatorDoc, customCalcProvider);\n    }\n\n    /**\n     * Fill references in an object or string.\n     * @param objectOrString - The object or string to find and fill in references within.\n     * @param dataDoc - The object that provides the data to that can be referenced. It may be the same object as as the `objectOrString` parameter.\n     * @param remoteDocProvider - A callback that will be invoked when a remote document is referenced and needed.\n     * @param customDataProvider - A callback that will be invoked when a custom data accessor is encountered.\n     */\n    /*static async fillReferences(objectOrString: string | object,\n                                dataDoc: any,\n                                remoteDocProvider?: RemoteDocProvider,\n                                customDataProvider?: CustomCalcProvider): Promise<any> {\n        return JSONCalc._fillReferences(objectOrString, dataDoc, null, remoteDocProvider, {}, customDataProvider);\n    }*/\n\n    /**\n     * Fill references in an object at the given path.\n     * @param object - The to find and fill references within.\n     * @param path - The path within the object find and fill references. Anything at or below this path will be procesed.\n     * @param remoteDocProvider - A callback that will be invoked when a remote document is referenced and needed.\n     * @param customDataProvider - A callback that will be invoked when a custom data accessor is encountered.\n     * @param defaultValue - If no value is found, this optional value will be returned.\n     */\n    /*static async get(object: object,\n                     path: string | string[],\n                     remoteDocProvider?: RemoteDocProvider,\n                     customDataProvider?: CustomCalcProvider,\n                     defaultValue?: any): Promise<any> {\n        let dataDoc = cloneDeep(object);\n        let value = isNil(path) || path.length === 0 ? dataDoc : get(object, path);\n\n        value = await JSONCalc.fillReferences(value, dataDoc, remoteDocProvider, customDataProvider);\n\n        if (isNil(value)) {\n            return defaultValue;\n        }\n\n        return value;\n    }*/\n}"]}